<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flex Grid CSS — Generator</title>
<link rel="stylesheet" href="style.css">
<style>
/* === Config Bar === */
.config-bar {
  background: linear-gradient(135deg, #16213e 0%, #1a2a4a 100%);
  border: 1px solid #2a3a5a;
  border-radius: 12px;
  padding: 1.25rem 1.5rem;
  margin-bottom: 1.5rem;
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 1.25rem;
  align-items: end;
}

@media (max-width: 900px) {
  .config-bar { grid-template-columns: repeat(2, 1fr); }
}

@media (max-width: 500px) {
  .config-bar { grid-template-columns: 1fr; }
}

.field label {
  display: block;
  font-size: 0.8rem;
  color: #7a8aaa;
  margin-bottom: 0.4rem;
}

.field input {
  width: 100%;
  background: #0a0f1e;
  border: 1px solid #2a3a5a;
  border-radius: 8px;
  padding: 0.6rem 0.85rem;
  color: #d4d4e0;
  font-family: monospace;
  font-size: 0.95rem;
  transition: border-color 0.15s;
}

.field input:focus {
  outline: none;
  border-color: #40c8c4;
  box-shadow: 0 0 0 2px rgba(64, 200, 196, 0.15);
}

/* === Options Row === */
.options-row {
  display: flex;
  gap: 1.25rem;
  align-items: center;
  flex-wrap: wrap;
  margin-bottom: 1.5rem;
}

.toggle {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.8rem;
  color: #6a6a90;
  cursor: pointer;
}

.toggle input { display: none; }

.toggle .switch {
  width: 36px;
  height: 20px;
  background: #1a1a35;
  border: 1px solid #2a2a4a;
  border-radius: 10px;
  position: relative;
  transition: all 0.2s;
}

.toggle .switch::after {
  content: '';
  position: absolute;
  top: 2px;
  left: 2px;
  width: 14px;
  height: 14px;
  background: #555;
  border-radius: 50%;
  transition: all 0.2s;
}

.toggle input:checked + .switch {
  background: #1a3a3a;
  border-color: #40c8c4;
}

.toggle input:checked + .switch::after {
  left: 18px;
  background: #40c8c4;
}

/* === Output === */
.output-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.75rem;
}

.output-header h3 {
  font-size: 0.85rem;
  color: #8888cc;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.copy-btn {
  padding: 0.35rem 0.9rem;
  background: #1a1a35;
  color: #8888bb;
  border: 1px solid #2a2a4a;
  border-radius: 6px;
  font-size: 0.75rem;
  cursor: pointer;
  transition: all 0.15s;
}

.copy-btn:hover { border-color: #e94560; color: #e94560; }
.copy-btn.copied { border-color: #40c057; color: #40c057; }

.stats {
  display: flex;
  flex-wrap: wrap;
  gap: 0.4rem 1.25rem;
  font-size: 0.8rem;
  color: #555580;
  margin-bottom: 0.75rem;
}

.stats b { color: #e94560; }
.stats .sep { color: #2a2a4a; }

#output {
  background: #0e0e1a;
  border: 1px solid #2a2a4a;
  border-radius: 10px;
  padding: 1.25rem;
  font-family: "SF Mono", "Fira Code", monospace;
  font-size: 0.78rem;
  line-height: 1.6;
  color: #b0b0d0;
  white-space: pre;
  overflow-x: auto;
  tab-size: 2;
  min-height: 300px;
}
</style>
</head>
<body>

<nav>
  <a href="index.html">Demo</a>
  <a href="generator.html" class="active">Generator</a>
  <span class="spacer"></span>
  <a href="https://github.com/mike-tuxedo/flexgrid-css" class="github">GitHub</a>
</nav>

<main>
  <h1>Container Query Generator</h1>
  <p class="subtitle">Generates container queries for any combination of schemas, gaps and min-widths.</p>

  <!-- Config Bar -->
  <div class="config-bar">
    <div class="field">
      <label>FlexGrid Prefix</label>
      <input type="text" id="prefix" value="fg">
    </div>
    <div class="field">
      <label>Flex Schemas</label>
      <input type="text" id="schemas" value="6321,42" placeholder="6321,421,31">
    </div>
    <div class="field">
      <label>Gap Variants</label>
      <input type="text" id="gaps" value="10,20,40,60">
    </div>
    <div class="field">
      <label>Min-Width Variants</label>
      <input type="text" id="mins" value="100,200,300">
    </div>
  </div>

  <!-- Options -->
  <div class="options-row">
    <label class="toggle">
      <input type="checkbox" id="includeBase" checked>
      <span class="switch"></span>
      Include base styles
    </label>
  </div>

  <!-- Output -->
  <div class="output-header">
    <h3>Generated CSS</h3>
    <button class="copy-btn" onclick="copyOutput(this, false)">Copy</button>
    <button class="copy-btn" onclick="copyOutput(this, true)">Copy minified</button>
  </div>
  <div class="stats" id="stats"></div>
  <div id="output"></div>
</main>

<script>
function parseCSV(str) {
  return str.split(',').map(s => s.trim()).filter(Boolean);
}

function parseSchema(str) {
  // "6321" → [6,3,2,1], "421" → [4,2,1]
  return [...str].map(Number).filter(n => n > 0);
}

function gzipSize(str) {
  const raw = new TextEncoder().encode(str);
  const rawLen = raw.length;
  if (rawLen === 0) return 0;

  const freq = new Uint32Array(256);
  for (const b of raw) freq[b]++;

  let entropy = 0;
  for (let i = 0; i < 256; i++) {
    if (freq[i] === 0) continue;
    const p = freq[i] / rawLen;
    entropy -= p * Math.log2(p);
  }

  const entropyRatio = entropy / 8;
  const lz77Factor = 0.75;
  return Math.max(Math.ceil(rawLen * entropyRatio * lz77Factor) + 20, 20);
}

function minifyCSS(css) {
  return css
    .replace(/\/\*[\s\S]*?\*\//g, '')
    .replace(/\n/g, '')
    .replace(/\s{2,}/g, ' ')
    .replace(/\s*([{}:;,>*])\s*/g, '$1')
    .replace(/;}/g, '}')
    .trim();
}

function formatKB(bytes) {
  if (bytes < 1024) return bytes + ' B';
  return (bytes / 1024).toFixed(2) + ' KB';
}

function generate() {
  const prefix = document.getElementById('prefix').value.trim() || 'fg';
  const schemaStrs = parseCSV(document.getElementById('schemas').value);
  const gaps = parseCSV(document.getElementById('gaps').value).map(Number).filter(n => n > 0);
  const mins = parseCSV(document.getElementById('mins').value).map(Number).filter(n => n > 0);
  const includeBase = document.getElementById('includeBase').checked;

  const schemas = schemaStrs.map(s => ({ raw: s, steps: parseSchema(s) })).filter(s => s.steps.length >= 2);

  if (schemas.length === 0 || gaps.length === 0 || mins.length === 0) {
    document.getElementById('output').textContent = '/* Need at least 1 schema (2+ digits), 1 gap and 1 min-width */';
    document.getElementById('stats').innerHTML = '';
    return;
  }

  const lines = [];

  if (includeBase) {
    lines.push('/* === Flex Grid CSS === */');
    lines.push('.' + prefix + ' { display: flex; justify-content: center; flex-wrap: wrap; container-type: inline-size; gap: var(--gap, 0px); }');
    lines.push('.' + prefix + ' > * { --items: 1; width: max(var(--min, 0px), calc(100% / var(--items) - (var(--items) - 1) * var(--gap, 0px) / var(--items))); max-width: 100%; }');
    lines.push('');

    for (const schema of schemas) {
      lines.push('.' + prefix + '-' + schema.raw + ' > * { --items: ' + schema.steps[0] + '; }');
    }
    lines.push('');

    for (const g of gaps) {
      lines.push('.' + prefix + '-gap' + g + ' { --gap: ' + g + 'px; }');
    }
    lines.push('');

    for (const m of mins) {
      lines.push('.' + prefix + '-min' + m + ' > * { --min: ' + m + 'px; }');
    }
    lines.push('');
  }

  let totalQueries = 0;

  for (const schema of schemas) {
    const name = prefix + '-' + schema.raw;
    const steps = schema.steps;

    if (schemas.length > 1 || includeBase) {
      lines.push('/* === ' + name + ' (' + steps.join(' -> ') + ') === */');
    }

    const entries = [];
    for (let i = 0; i < steps.length - 1; i++) {
      const fromCols = steps[i];
      const toCols = steps[i + 1];

      for (const gap of gaps) {
        for (const min of mins) {
          const bp = fromCols * min + (fromCols - 1) * gap - 1;
          entries.push({ bp, gap, min, toCols, fromCols });
        }
      }
    }

    entries.sort((a, b) => b.bp - a.bp);

    let lastTransition = '';
    for (const e of entries) {
      const transition = e.fromCols + ' -> ' + e.toCols;
      if (transition !== lastTransition) {
        if (lastTransition) lines.push('');
        lines.push('/* ' + transition + ' */');
        lastTransition = transition;
      }
      lines.push('@container (max-inline-size: ' + e.bp + 'px) { .' + name + '.' + prefix + '-gap' + e.gap + '.' + prefix + '-min' + e.min + ' > * { --items: ' + e.toCols + '; } }');
      totalQueries++;
    }

    lines.push('');
  }

  const cssText = lines.join('\n').replace(/\n{3,}/g, '\n\n').trim();
  const minified = minifyCSS(cssText);
  const rawBytes = new TextEncoder().encode(cssText).length;
  const minBytes = new TextEncoder().encode(minified).length;
  const gzBytes = gzipSize(minified);

  document.getElementById('output').textContent = cssText;
  document.getElementById('stats').innerHTML =
    (schemas.length > 1 ? '<b>' + schemas.length + '</b> schemas <span class="sep">|</span> ' : '') +
    '<b>' + totalQueries + '</b> container queries' +
    ' <span class="sep">|</span> ' +
    gaps.length + ' gaps &times; ' + mins.length + ' mins' +
    ' <span class="sep">|</span> ' +
    '<b>' + formatKB(rawBytes) + '</b> raw' +
    ' <span class="sep">|</span> ' +
    '<b>' + formatKB(minBytes) + '</b> minified' +
    ' <span class="sep">|</span> ' +
    '~<b>' + formatKB(gzBytes) + '</b> gzip';
}

function copyOutput(btn, minified) {
  const text = document.getElementById('output').textContent;
  const content = minified ? minifyCSS(text) : text;
  const label = minified ? 'Copy minified' : 'Copy';
  navigator.clipboard.writeText(content).then(() => {
    btn.textContent = 'Copied!';
    btn.classList.add('copied');
    setTimeout(() => {
      btn.textContent = label;
      btn.classList.remove('copied');
    }, 2000);
  });
}

generate();

document.querySelectorAll('input').forEach(el => {
  el.addEventListener('change', generate);
  el.addEventListener('input', generate);
});
</script>

</body>
</html>
