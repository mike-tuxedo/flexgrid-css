<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flex Grid CSS — Generator</title>
<link rel="stylesheet" href="style.css">
<style>
/* === Generator UI === */
.generator {
  display: grid;
  grid-template-columns: 320px 1fr;
  gap: 2rem;
  align-items: start;
}

@media (max-width: 800px) {
  .generator { grid-template-columns: 1fr; }
}

.panel {
  background: #16162a;
  border: 1px solid #2a2a4a;
  border-radius: 12px;
  padding: 1.5rem;
  position: sticky;
  top: 1rem;
}

.panel h3 {
  font-size: 0.85rem;
  color: #8888cc;
  margin-bottom: 1rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.field {
  margin-bottom: 1.25rem;
}

.field label {
  display: block;
  font-size: 0.8rem;
  color: #6a6a90;
  margin-bottom: 0.4rem;
}

.field input[type="text"],
.field select {
  width: 100%;
  background: #0e0e1a;
  border: 1px solid #2a2a4a;
  border-radius: 6px;
  padding: 0.5rem 0.75rem;
  color: #d4d4e0;
  font-family: monospace;
  font-size: 0.85rem;
}

.field select { cursor: pointer; }
.field input:focus, .field select:focus { outline: none; border-color: #e94560; }

.chip-group {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

.chip-group label {
  display: inline-block;
  margin: 0;
}

.chip-group input[type="checkbox"] { display: none; }

.chip-group span {
  display: inline-block;
  padding: 0.3rem 0.7rem;
  border-radius: 6px;
  font-size: 0.8rem;
  font-family: monospace;
  background: #0e0e1a;
  border: 1px solid #2a2a4a;
  color: #6a6a90;
  cursor: pointer;
  transition: all 0.15s;
}

.chip-group input:checked + span {
  background: #2a1a30;
  border-color: #e94560;
  color: #e94560;
}

.btn {
  width: 100%;
  padding: 0.65rem 1rem;
  background: #e94560;
  color: #fff;
  border: none;
  border-radius: 8px;
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  transition: background 0.15s;
}

.btn:hover { background: #d63050; }

/* === Output === */
.output-wrap {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.output-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.output-header h3 {
  font-size: 0.85rem;
  color: #8888cc;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.copy-btn {
  padding: 0.35rem 0.9rem;
  background: #1a1a35;
  color: #8888bb;
  border: 1px solid #2a2a4a;
  border-radius: 6px;
  font-size: 0.75rem;
  cursor: pointer;
  transition: all 0.15s;
}

.copy-btn:hover { border-color: #e94560; color: #e94560; }
.copy-btn.copied { border-color: #40c057; color: #40c057; }

#output {
  background: #0e0e1a;
  border: 1px solid #2a2a4a;
  border-radius: 10px;
  padding: 1.25rem;
  font-family: "SF Mono", "Fira Code", monospace;
  font-size: 0.78rem;
  line-height: 1.6;
  color: #b0b0d0;
  white-space: pre;
  overflow-x: auto;
  tab-size: 2;
  min-height: 300px;
}

.stats {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem 1.5rem;
  font-size: 0.8rem;
  color: #555580;
}

.stats b { color: #e94560; }
.stats .sep { color: #2a2a4a; }
</style>
</head>
<body>

<nav>
  <a href="index.html">Demo</a>
  <a href="generator.html" class="active">Generator</a>
</nav>

<main>
  <h1>Container Query Generator</h1>
  <p class="subtitle">Generates container queries for any pattern/gap/min-width combination.</p>

  <div class="generator">
    <!-- Config Panel -->
    <div class="panel">
      <h3>Configuration</h3>

      <div class="field">
        <label>Pattern (column cascade, comma-separated)</label>
        <input type="text" id="pattern" value="6,3,2,1">
      </div>

      <div class="field">
        <label>Class name (e.g. fg-6321)</label>
        <input type="text" id="className" value="fg-6321">
      </div>

      <div class="field">
        <label>Gaps (px)</label>
        <div class="chip-group" id="gapChips">
          <label><input type="checkbox" value="5"><span>5</span></label>
          <label><input type="checkbox" value="10" checked><span>10</span></label>
          <label><input type="checkbox" value="20" checked><span>20</span></label>
          <label><input type="checkbox" value="40" checked><span>40</span></label>
          <label><input type="checkbox" value="60"><span>60</span></label>
          <label><input type="checkbox" value="80"><span>80</span></label>
        </div>
      </div>

      <div class="field">
        <label>Min-widths (px)</label>
        <div class="chip-group" id="minChips">
          <label><input type="checkbox" value="100" checked><span>100</span></label>
          <label><input type="checkbox" value="150"><span>150</span></label>
          <label><input type="checkbox" value="200" checked><span>200</span></label>
          <label><input type="checkbox" value="250"><span>250</span></label>
          <label><input type="checkbox" value="300" checked><span>300</span></label>
          <label><input type="checkbox" value="400"><span>400</span></label>
        </div>
      </div>

      <div class="field">
        <label>Include base styles?</label>
        <select id="includeBase">
          <option value="yes">Yes — complete CSS</option>
          <option value="no">No — container queries only</option>
        </select>
      </div>

      <button class="btn" onclick="generate()">Generate CSS</button>
    </div>

    <!-- Output -->
    <div class="output-wrap">
      <div class="output-header">
        <h3>Generated CSS</h3>
        <button class="copy-btn" onclick="copyOutput(this)">Copy</button>
      </div>
      <div class="stats" id="stats"></div>
      <div id="output"></div>
    </div>
  </div>
</main>

<script>
function getCheckedValues(id) {
  return [...document.querySelectorAll('#' + id + ' input:checked')].map(c => Number(c.value));
}

function gzipSize(str) {
  // DEFLATE estimation: measure redundancy via compression ratio heuristic
  // Container queries are highly repetitive, so they compress very well.
  // We simulate this by counting unique vs repeated patterns.
  const raw = new TextEncoder().encode(str);
  const rawLen = raw.length;

  if (rawLen === 0) return 0;

  // Byte frequency entropy estimation
  const freq = new Uint32Array(256);
  for (const b of raw) freq[b]++;

  let entropy = 0;
  for (let i = 0; i < 256; i++) {
    if (freq[i] === 0) continue;
    const p = freq[i] / rawLen;
    entropy -= p * Math.log2(p);
  }

  // Entropy gives bits per byte. DEFLATE also exploits repeated substrings,
  // so actual compression is better than pure entropy. Apply a factor for
  // the LZ77 back-reference gain on repetitive CSS.
  const entropyRatio = entropy / 8;
  const lz77Factor = 0.75; // CSS container queries are very repetitive
  const estimated = Math.ceil(rawLen * entropyRatio * lz77Factor) + 20; // +20 for gzip header/footer

  return Math.max(estimated, 20);
}

function minifyCSS(css) {
  return css
    .replace(/\/\*[\s\S]*?\*\//g, '')  // remove comments
    .replace(/\n/g, '')                 // remove newlines
    .replace(/\s{2,}/g, ' ')           // collapse whitespace
    .replace(/\s*([{}:;,>*])\s*/g, '$1') // remove space around syntax chars
    .replace(/;}/g, '}')               // remove last semicolons
    .trim();
}

function formatKB(bytes) {
  if (bytes < 1024) return bytes + ' B';
  return (bytes / 1024).toFixed(2) + ' KB';
}

function generate() {
  const steps = document.getElementById('pattern').value.split(',').map(s => Number(s.trim())).filter(n => n > 0);
  const name = document.getElementById('className').value.trim() || 'fg-6321';
  const gaps = getCheckedValues('gapChips');
  const mins = getCheckedValues('minChips');
  const includeBase = document.getElementById('includeBase').value === 'yes';

  if (steps.length < 2 || gaps.length === 0 || mins.length === 0) {
    document.getElementById('output').textContent = '/* Need at least 2 pattern steps, 1 gap and 1 min-width */';
    document.getElementById('stats').innerHTML = '';
    return;
  }

  const lines = [];

  if (includeBase) {
    lines.push('/* === Flex Grid CSS === */');
    lines.push('.fg { display: flex; justify-content: center; flex-wrap: wrap; container-type: inline-size; gap: var(--gap, 0px); }');
    lines.push('.fg > * { --items: 1; width: max(var(--min, 0px), calc(100% / var(--items) - (var(--items) - 1) * var(--gap, 0px) / var(--items))); max-width: 100%; }');
    lines.push('');
    lines.push('.' + name + ' > * { --items: ' + steps[0] + '; }');
    lines.push('');

    for (const g of gaps) {
      lines.push('.fg-gap' + g + ' { --gap: ' + g + 'px; }');
    }
    lines.push('');

    for (const m of mins) {
      lines.push('.fg-min' + m + ' > * { --min: ' + m + 'px; }');
    }
    lines.push('');
  }

  // Collect all breakpoints
  const entries = [];
  for (let i = 0; i < steps.length - 1; i++) {
    const fromCols = steps[i];
    const toCols = steps[i + 1];

    for (const gap of gaps) {
      for (const min of mins) {
        const bp = fromCols * min + (fromCols - 1) * gap - 1;
        entries.push({ bp, gap, min, toCols, fromCols });
      }
    }
  }

  // Sort by breakpoint descending
  entries.sort((a, b) => b.bp - a.bp);

  // Group by transition for comments
  let lastTransition = '';
  let queryCount = 0;

  for (const e of entries) {
    const transition = e.fromCols + ' -> ' + e.toCols;
    if (transition !== lastTransition) {
      if (lastTransition) lines.push('');
      lines.push('/* ' + transition + ' */');
      lastTransition = transition;
    }
    lines.push('@container (max-inline-size: ' + e.bp + 'px) { .' + name + '.fg-gap' + e.gap + '.fg-min' + e.min + ' > * { --items: ' + e.toCols + '; } }');
    queryCount++;
  }

  const cssText = lines.join('\n');
  const minified = minifyCSS(cssText);
  const rawBytes = new TextEncoder().encode(cssText).length;
  const minBytes = new TextEncoder().encode(minified).length;
  const gzBytes = gzipSize(minified);

  document.getElementById('output').textContent = cssText;
  document.getElementById('stats').innerHTML =
    '<b>' + queryCount + '</b> container queries' +
    ' <span class="sep">|</span> ' +
    gaps.length + ' gaps &times; ' + mins.length + ' mins &times; ' +
    (steps.length - 1) + ' transitions' +
    ' <span class="sep">|</span> ' +
    '<b>' + formatKB(rawBytes) + '</b> raw' +
    ' <span class="sep">|</span> ' +
    '<b>' + formatKB(minBytes) + '</b> minified' +
    ' <span class="sep">|</span> ' +
    '~<b>' + formatKB(gzBytes) + '</b> gzip';
}

function copyOutput(btn) {
  const text = document.getElementById('output').textContent;
  navigator.clipboard.writeText(text).then(() => {
    btn.textContent = 'Copied!';
    btn.classList.add('copied');
    setTimeout(() => {
      btn.textContent = 'Copy';
      btn.classList.remove('copied');
    }, 2000);
  });
}

// Generate on load
generate();

// Auto-regenerate on any config change
document.querySelectorAll('.panel input, .panel select').forEach(el => {
  el.addEventListener('change', generate);
  el.addEventListener('input', generate);
});
</script>

</body>
</html>
